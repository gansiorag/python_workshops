'''
 This module performanse provides immutable UUID objects (the UUID class) and 
 the functions uuid1(), uuid3(), uuid4(), uuid5() for generating version 1, 3, 4, and 5 UUIDs 
 as specified in RFC 4122.
If all you want is a unique ID, you should probably call uuid1() or uuid4(). 
Note that uuid1() may compromise privacy since it 
creates a UUID containing the computer’s network address. uuid4() creates a random UUID. 

All instances of UUID have an is_safe attribute which relays any information about the UUID’s safety, using this enumeration:

class uuid.SafeUUID
    New in version 3.7.
    safe
        The UUID was generated by the platform in a multiprocessing-safe way.

    unsafe
        The UUID was not generated in a multiprocessing-safe way.

    unknown
    The platform does not provide information on whether the UUID was generated safely or not.

class uuid.cprint(f'uuid {uui}')hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=SafeUUID.unknown)

UUID instances have these read-only attributes:

UUID.bytes
The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).

UUID.bytes_le
The UUID as a 16-byte string (with time_low, time_mid, and time_hi_version in little-endian byte order).

UUID.fields
A tuple of the six integer fields of the UUID, which are also available as six individual attributes and two derived attributes:

    Field            |         Meaning

time_low             | the first 32 bits of the UUID
time_mid             | the next 16 bits of the UUID
time_hi_version      | the next 16 bits of the UUID
clock_seq_hi_variant | the next 8 bits of the UUID
clock_seq_low        | the next 8 bits of the UUID
node                 | the last 48 bits of the UUID
time                 | the 60-bit timestamp
clock_seq            | the 14-bit sequence number

UUID.hex
The UUID as a 32-character lowercase hexadecimal string.

UUID.int
The UUID as a 128-bit integer.

UUID.urn
The UUID as a URN as specified in RFC 4122.

UUID.variant
The UUID variant, which determines the internal layout of the UUID. This will be one of the 
constants RESERVED_NCS, RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE.

UUID.version
The UUID version number (1 through 5, meaningful only when the variant is RFC_4122).

UUID.is_safe
An enumeration of SafeUUID which indicates whether the platform generated the UUID in a 
multiprocessing-safe way.

New in version 3.7.

The uuid module defines the following functions:

uuid.getnode()
Get the hardware address as a 48-bit positive integer. The first time this runs, it may 
launch a separate program, which could be quite slow. If all attempts to obtain the hardware address 
fail, we choose a random 48-bit number with the multicast bit (least significant bit of the first octet) 
set to 1 as recommended in RFC 4122. “Hardware address” means the MAC address of a network interface.
On a machine with multiple network interfaces, universally administered MAC addresses (i.e. where the 
second least significant bit of the first octet is unset) will be preferred over locally administered 
MAC addresses, but with no other ordering guarantees.

Changed in version 3.7: Universally administered MAC addresses are preferred over locally 
administered MAC addresses, since the former are guaranteed to be globally unique, while the 
latter are not.

uuid.uuid1(node=None, clock_seq=None)
Generate a UUID from a host ID, sequence number, and the current time. If node is not given, 
getnode() is used to obtain the hardware address. If clock_seq is given, it is used as the sequence 
number; otherwise a random 14-bit sequence number is chosen.

uuid.uuid3(namespace, name)
Generate a UUID based on the MD5 hash of a namespace identifier (which is a UUID) and a 
name (which is a string).

uuid.uuid4()
Generate a random UUID.

uuid.uuid5(namespace, name)
Generate a UUID based on the SHA-1 hash of a namespace identifier (which is a UUID) and a name (which 
is a string).

The uuid module defines the following namespace identifiers for use with uuid3() or uuid5().

uuid.NAMESPACE_DNS
When this namespace is specified, the name string is a fully qualified domain name.

uuid.NAMESPACE_URL
When this namespace is specified, the name string is a URL.

uuid.NAMESPACE_OID
When this namespace is specified, the name string is an ISO OID.

uuid.NAMESPACE_X500
When this namespace is specified, the name string is an X.500 DN in DER or a text output format.

The uuid module defines the following constants for the possible values of the variant attribute:

uuid.RESERVED_NCS
Reserved for NCS compatibility.

uuid.RFC_4122
Specifies the UUID layout given in RFC 4122.

uuid.RESERVED_MICROSOFT
Reserved for Microsoft compatibility.

uuid.RESERVED_FUTURE
Reserved for future definition.
   
Athor: Gansior Alexander, gansior@gansior.ru, +79173383804
Starting 2022/08/06
Ending 2022/08/08
    
'''
    
from termcolor import cprint
'''
Text colors: grey red green yellow blue magenta cyan white
Text highlights: on_grey on_red on_green on_yellow on_blue on_magenta on_cyan on_white
Attributes: bold dark underline blink reverse concealed
'''

import uuid
    
    
def prog1(keySub):
    """I generate uuid for use in database

    Args:
        keySub (str): this any word for generate on base uuid 
    """
    uuidSub = uuid.uuid3(uuid.NAMESPACE_DNS, keySub)
    cprint(f"type uuid = {type(uuidSub)}" , 'red', attrs=['bold'])
    cprint(f"Converter uuid to string = {str(uuidSub)}" , 'blue', attrs=['bold'])
    print("="*100)
    uuidSub = uuid.uuid3(uuid.RFC_4122, bytes(keySub, 'utf-8'))
    cprint(f"type uuid = {type(uuidSub)}" , 'red', attrs=['bold'])
    cprint(f"Converter uuid to string = {str(uuidSub)}" , 'blue', attrs=['bold'])
    
    
def prog2():
    # make a UUID based on the host ID and current time
    #uuid.uuid1()
    print()
    cprint(f'uuid.uuid1() =  {uuid.uuid1()}' , 'red', attrs=['bold'])

    # make a UUID using an MD5 hash of a namespace UUID and a name
    # uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')
    print()
    cprint(f"uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org') --> {uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')}", 'green', attrs=['bold'])

    # make a random UUID
    #uuid.uuid4()
    print()
    cprint(f'uuid.uuid4() {uuid.uuid4()}', 'yellow', attrs=['bold'])

    # make a UUID using a SHA-1 hash of a namespace UUID and a name
    #uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')
    #cprint(f'uuid {uui}')'886313e1-3b8a-5372-9b90-0c9aee199e5d')

    # make a UUID from a string of hex digits (braces and hyphens ignored)
    print()
    x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')
    cprint(f" x --> {x}", 'magenta', attrs=['bold'])

    # convert a UUID to a string of hex digits in standard form
    print()
    cprint(f'str(x) -->  {str(x)}', 'red', attrs=['bold'])

    # get the raw 16 bytes of the UUID
    print()
    cprint(f'x.bytes -->  {str(x.bytes)}', 'blue', attrs=['bold'])
  
    # make a UUID from a 16-byte string
    # uuid.UUID(bytes=x.bytes)
    # cprint(f'uuid.UUID(bytes=x.bytes) --> {uuid.UUID(bytes=x.bytes)}')
    
    
if __name__ == '__main__':
    name='Any custom text'
    prog1(name)
    prog2()